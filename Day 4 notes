<<<<<<<<<<<<<<<<ArrayBuffer>>>>>>>>>>>>>>>>>>
TypedArray is the combination of uit8Array, uint16array, uint32array etc. 
They have indexes and iterable.

A typed array constructor (be it Int8Array or Float64Array, doesnâ€™t matter) behaves differently depending on argument types.

There are 5 variants of arguments:

new TypedArray(buffer, [byteOffset], [length]);

new TypedArray(object);

new TypedArray(typedArray);

new TypedArray(length);

new TypedArray();


Data Types: TypedArrays provide a way to work with binary data using a fixed type. 
The available data types include Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, and Float64Array.

Fixed Length: Each TypedArray has a fixed length, meaning you cannot change the number of elements after creation. To change the length, you must create a new TypedArray.

Memory Efficiency: TypedArrays are memory-efficient because they store data in a contiguous memory block and have a fixed type. 
This is especially useful when dealing with large datasets or interfacing with lower-level APIs.

Creation: You can create a TypedArray from various sources, including existing arrays, ArrayBuffer, or shared memory using constructors like Uint8Array, Int32Array, etc.

const array = new Uint8Array([1, 2, 3]);


ArrayBuffer: TypedArrays are often used in conjunction with ArrayBuffer, which is a low-level binary data buffer. ArrayBuffer can be shared among different TypedArrays.

 eg, const buffer = new ArrayBuffer(16);
const view1 = new Int8Array(buffer);
const view2 = new Uint32Array(buffer);

Indexed Access: You can access elements in a TypedArray using the standard array indexing notation.

const value = array[0];

data Manipulation: TypedArrays provide methods to manipulate data, such as set, subarray, and more, to copy, slice, or modify portions of the data efficiently.

eg, const newArray = array.subarray(1, 3);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<<-------------Out-bound-behaviour----------->>>>>>>>>>
 In JavaScript, out-of-bounds behavior refers to attempting to access or modify elements in an array or other data structures at an index that is outside the valid range of indices.

for example:

const arr = [1, 2, 3];
console.log(arr[10]); // Outputs: undefined

Array Length: The length property of an array indicates the number of elements in the array. If you access an index greater than or equal to the length, you're accessing an out-of-bounds index.
example:

const arr = [1, 2, 3];
console.log(arr.length); // Outputs: 3
console.log(arr[3]); // Outputs: undefined (out of bounds)

Bounds Checking:
JavaScript does not perform bounds checking by default. It's up to the developer to ensure that they don't access out-of-bounds indices.

example: const arr = [1, 2, 3];
const index = 10;

if (index >= 0 && index < arr.length) {
  console.log(arr[index]);
} else {
  console.log("Index is out of bounds");
}




